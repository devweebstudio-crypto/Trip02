<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Trip Map</title>
  <style>
    :root{--bg:#0f172a;--panel:#0b1220;--line:#253148;--muted:#94a3b8;--accent:#22c55e;--danger:#ef4444}
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:#e5e7eb;font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
    header{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;background:#111827;border-bottom:1px solid rgba(255,255,255,.06)}
    .left{display:flex;align-items:center;gap:8px}
    .title{font-weight:800}
    .sub{color:var(--muted);font-size:12px}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button{padding:8px 12px;border-radius:10px;border:1px solid #334155;background:#1f2937;color:#e5e7eb;cursor:pointer}
    .primary{background:var(--accent);border:none;color:#052e16}
    .danger{background:var(--danger);border:none;color:#2a0b0b}
    main{height:calc(100vh - 56px);display:grid;grid-template-columns:1fr 330px}
    #map{width:100%;height:100%}
    aside{background:var(--panel);border-left:1px solid var(--line);display:flex;flex-direction:column;min-height:0}
    .panel{padding:10px;display:flex;flex-direction:column;gap:10px;min-height:0}
    .muted{color:var(--muted)}
    .member{border:1px solid #2a3a58;background:#0b1324;border-radius:12px;padding:10px;display:flex;justify-content:space-between;align-items:center;gap:8px}
    .member .name{font-weight:800}
    .member .sub{font-size:12px;color:var(--muted)}
    .member .act{display:flex;gap:6px}
    .badge{display:inline-block;padding:2px 6px;border-radius:999px;border:1px solid #2a3a58;background:#0b1324;font-size:11px}
    .list{overflow:auto;min-height:0;display:flex;flex-direction:column;gap:8px}
    .msg{font-size:13px}
    @media (max-width:900px){
      main{grid-template-columns:1fr}
      aside{position:fixed;left:0;right:0;bottom:0;max-height:46vh;border-left:0;border-top:1px solid var(--line)}
    }
  </style>
</head>
<body>
  <header>
    <div class="left">
      <button id="backBtn">← Back</button>
      <div>
        <div class="title" id="tripName">Trip</div>
        <div class="sub" id="tripMeta">—</div>
      </div>
    </div>
    <div class="row">
      <span class="badge" id="tripCodeBadge" title="Join code"></span>
      <button id="endTripBtn" class="danger" style="display:none">End Trip</button>
    </div>
  </header>

  <main>
    <div id="map"></div>
    <aside>
      <div class="panel">
        <div class="row" style="justify-content:space-between">
          <div class="muted">Live members</div>
          <div class="sub" id="myStatus">—</div>
        </div>
        <div id="membersList" class="list"></div>
        <div id="msg" class="msg"></div>
      </div>
    </aside>
  </main>

  <!-- Google Maps (need geometry for distances) -->
  <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_GOOGLE_MAPS_API_KEY&libraries=geometry"></script>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore-compat.js"></script>

  <script>
    // ===== Firebase =====
    const firebaseConfig = {
      apiKey: "AIzaSyB529yOEmk9sDDcUiD5tkyCRsmJpvOn66s",
      authDomain: "tripapp-27b4f.firebaseapp.com",
      projectId: "tripapp-27b4f",
      storageBucket: "tripapp-27b4f.firebasestorage.app",
      messagingSenderId: "796205117191",
      appId: "1:796205117191:web:30507cc680c3b630b51fa2"
    };
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    // ===== URL / UI refs =====
    const params = new URLSearchParams(location.search);
    const tripId = params.get("tripId");
    const backBtn = document.getElementById("backBtn");
    const tripNameEl = document.getElementById("tripName");
    const tripMetaEl = document.getElementById("tripMeta");
    const tripCodeBadge = document.getElementById("tripCodeBadge");
    const endTripBtn = document.getElementById("endTripBtn");
    const membersList = document.getElementById("membersList");
    const myStatusEl = document.getElementById("myStatus");
    const msgEl = document.getElementById("msg");

    function setMsg(t){ msgEl.textContent = t || ""; }

    // ===== Globals =====
    let me=null, emailHash=null, profile=null, isAdmin=false;
    let map, myMarker=null, myPath=null, myWatch=null;
    const markers = new Map();    // uid -> marker
    const polylines = new Map();  // uid -> polyline
    const infos = new Map();      // uid -> {name, phone, lat, lng, ts, color}
    let firstBoundsFit = false;
    const COLORS = {};

    // ===== Helpers =====
    async function sha256Hex(txt){
      const enc=new TextEncoder().encode(txt);
      const buf=await crypto.subtle.digest("SHA-256",enc);
      return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,"0")).join("");
    }
    function colorFor(uid){
      if(COLORS[uid]) return COLORS[uid];
      // simple hash to HSL
      let h=0; for(let i=0;i<uid.length;i++) h=(h*31+uid.charCodeAt(i))%360;
      const c = `hsl(${h} 90% 55%)`;
      COLORS[uid]=c; return c;
    }
    function fmtDist(m){
      if(m<1000) return `${Math.round(m)} m`;
      return (m/1000).toFixed(2)+' km';
    }
    function ago(ts){
      if(!ts) return '—';
      const s = Math.floor((Date.now()-ts)/1000);
      if(s<60) return `${s}s ago`;
      const m=Math.floor(s/60); if(m<60) return `${m}m ago`;
      const h=Math.floor(m/60); return `${h}h ago`;
    }
    function dayKey(ts=Date.now()){
      const d=new Date(ts); const y=d.getFullYear(), m=String(d.getMonth()+1).padStart(2,'0'), dd=String(d.getDate()).padStart(2,'0');
      return `${y}-${m}-${dd}`;
    }

    // ===== Auth + session guard + kick-out watcher =====
    async function requireLogin(){
      return new Promise((resolve)=>{
        auth.onAuthStateChanged(async (u)=>{
          if(!u){ location.replace("index.html?next="+encodeURIComponent(location.pathname+location.search)); return; }
          me=u;
          try{
            const link = await db.collection("authLinks").doc(u.uid).get();
            if(!link.exists) throw new Error("No auth link");
            emailHash = link.data().emailHash;

            const profRef = db.collection("profiles").doc(emailHash);
            const profSnap = await profRef.get();
            if(!profSnap.exists || profSnap.data().activeUid !== u.uid){
              // not the active device
              await auth.signOut();
              location.replace("index.html?reason=kicked");
              return;
            }
            profile = profSnap.data();

            // kick-out listener
            profRef.onSnapshot(s=>{
              const d = s.data()||{};
              if(d.activeUid && d.activeUid !== me.uid){
                auth.signOut().finally(()=>{
                  localStorage.removeItem("tripapp_logged_in");
                  localStorage.removeItem("tripapp_emailHash");
                  location.replace("index.html?reason=kicked");
                });
              }
            });

            resolve();
          }catch(e){
            console.error(e);
            location.replace("index.html");
          }
        });
      });
    }

    // ===== Map init =====
    function initMap(){
      map = new google.maps.Map(document.getElementById("map"), {
        center: {lat:20.5937, lng:78.9629}, zoom: 5,
        mapTypeControl:false, fullscreenControl:true, streetViewControl:false
      });
      myPath = new google.maps.Polyline({
        path: [], geodesic:true, strokeOpacity:0.9, strokeWeight:4, strokeColor:"#00e676", map
      });
    }

    // ===== Load trip & membership =====
    async function loadTrip(){
      if(!tripId){ alert("Missing tripId"); location.replace("trips.html"); return; }
      const tripRef = db.collection("trips").doc(tripId);
      const [tripSnap, myMem] = await Promise.all([
        tripRef.get(),
        tripRef.collection("members").doc(me.uid).get()
      ]);
      if(!tripSnap.exists){ alert("Trip not found"); location.replace("trips.html"); return; }
      if(!myMem.exists){ alert("You are not a member of this trip"); location.replace("trips.html"); return; }

      const t = tripSnap.data();
      tripNameEl.textContent = t.name || "Trip";
      tripMetaEl.textContent = (t.isActive===false ? "Ended" : "Active") + (t.destination?.name ? ` • → ${t.destination.name}` : "");
      if (t.joinCodePlain) {
        tripCodeBadge.textContent = `Code: ${t.joinCodePlain}`;
        tripCodeBadge.style.display = "inline-block";
      } else {
        tripCodeBadge.style.display = "none";
      }

      isAdmin = (myMem.data().role === "admin");
      endTripBtn.style.display = isAdmin ? "inline-block" : "none";

      // seed names/phones
      const mems = await tripRef.collection("members").get();
      mems.forEach(d=>{
        const m = d.data();
        infos.set(d.id, { name: m.displayName || "Member", phone: m.phone || "", lat:null, lng:null, ts:null, color: colorFor(d.id) });
      });
      renderList(); // initial empty render
    }

    // ===== Live listener =====
    function attachLiveListener(){
      return db.collection("trips").doc(tripId).collection("live")
        .onSnapshot(snap=>{
          const bounds = new google.maps.LatLngBounds();
          let any = false;

          snap.forEach(doc=>{
            const uid = doc.id;
            const d = doc.data() || {};
            if(d.lat==null || d.lng==null) return;
            any = true;

            let inf = infos.get(uid) || { name:"Member", phone:"", color: colorFor(uid) };
            inf.lat = d.lat; inf.lng = d.lng; inf.ts = d.ts || Date.now();
            infos.set(uid, inf);

            // marker
            let mk = markers.get(uid);
            const pos = new google.maps.LatLng(d.lat, d.lng);
            if(!mk){
              mk = new google.maps.Marker({
                position: pos, map,
                icon: {
                  path: google.maps.SymbolPath.CIRCLE,
                  scale: 8,
                  fillColor: inf.color, fillOpacity: 1,
                  strokeColor: "#101010", strokeWeight: 1.5
                },
                label: { text: inf.name, color: "#ffffff", fontWeight: "bold" }
              });
              markers.set(uid, mk);
            }else{
              mk.setPosition(pos);
              mk.setLabel({ text: inf.name, color:"#fff", fontWeight:"bold" });
            }
            bounds.extend(pos);

            // polyline (ensure exists)
            if(!polylines.get(uid)){
              const pl = new google.maps.Polyline({
                path: [], geodesic:true, strokeOpacity: 0.85, strokeWeight: 3, strokeColor: inf.color, map
              });
              polylines.set(uid, pl);
            }
          });

          renderList();

          if(any){
            if(!firstBoundsFit){
              map.fitBounds(bounds);
              firstBoundsFit = true;
            }
          }
        }, err=>{
          console.error(err);
          setMsg("Live listener error: " + (err && err.message || err));
        });
    }

    // ===== Load today's tracks to draw paths =====
    async function loadTodayTracks(){
      const today = dayKey();
      const mems = Array.from(infos.keys());
      for(const uid of mems){
        try{
          const qs = await db.collection("trips").doc(tripId)
            .collection("tracks").doc(uid).collection(today)
            .orderBy("ts","desc").limit(400).get();
          const pts = qs.docs.map(d=>d.data()).reverse().map(p=> new google.maps.LatLng(p.lat,p.lng));
          if(pts.length){
            let pl = polylines.get(uid);
            if(!pl){
              pl = new google.maps.Polyline({
                path: pts, geodesic:true, strokeOpacity:0.85, strokeWeight:3, strokeColor: colorFor(uid), map
              });
              polylines.set(uid, pl);
            }else{
              pl.setPath(pts);
            }
          }
        }catch(e){ /* ignore per-user errors */ }
      }
    }

    // ===== My tracking (mandatory location) =====
    function ensureSecureAndGeo(){
      const isSecure = (location.protocol==="https:" || ["localhost","127.0.0.1"].includes(location.hostname));
      if(!isSecure) { alert("Please use HTTPS to enable GPS."); return false; }
      if(!("geolocation" in navigator)){ alert("Geolocation not supported."); return false; }
      return true;
    }

    async function startTracking(){
      if(!ensureSecureAndGeo()) return;

      // Probe permission
      try{
        await new Promise((res,rej)=>{
          navigator.geolocation.getCurrentPosition(()=>res(), (e)=>rej(e), { enableHighAccuracy:true, maximumAge:0, timeout:10000 });
        });
      }catch(e){
        alert("Please allow Location and turn it ON, then reload.");
        return;
      }

      const liveRef = db.collection("trips").doc(tripId).collection("live").doc(me.uid);
      const trackColl = db.collection("trips").doc(tripId).collection("tracks").doc(me.uid).collection(dayKey());

      // Offline queue for tracks
      const qKey = `trackQueue:${tripId}:${me.uid}`;
      async function flushQueue(){
        try{
          const raw = localStorage.getItem(qKey); if(!raw) return;
          const arr = JSON.parse(raw)||[]; if(!arr.length) return;
          while(arr.length){
            const chunk = arr.splice(0, 200);
            const batch = db.batch();
            chunk.forEach(p => batch.set(trackColl.doc(), p));
            await batch.commit();
          }
          localStorage.removeItem(qKey);
        }catch(e){ /* keep queue */ }
      }
      flushQueue();
      const flushTimer = setInterval(flushQueue, 5000);

      // My marker init color
      const myColor = "#00e676";

      myWatch = navigator.geolocation.watchPosition(async pos=>{
        const { latitude:lat, longitude:lng, speed, heading, accuracy } = pos.coords;
        const ts = Date.now();

        // A) Write live
        try{
          await liveRef.set({
            lat, lng, ts,
            speed: speed || 0, heading: heading || 0, accuracy: accuracy || 0
          }, { merge:true });
          myStatusEl.textContent = `Last: ${new Date(ts).toLocaleTimeString()}`;
        }catch(e){
          setMsg("Live write failed: " + (e && e.message || e));
        }

        // B) Update my marker & path
        const p = new google.maps.LatLng(lat,lng);
        if(!myMarker){
          myMarker = new google.maps.Marker({
            position: p, map,
            icon: { path: google.maps.SymbolPath.CIRCLE, scale: 9, fillColor: myColor, fillOpacity: 1, strokeColor:"#0a0a0a", strokeWeight:1.6 },
            label: { text: (profile?.name || "Me"), color:"#ffffff", fontWeight:"bold" }
          });
          map.setCenter(p); map.setZoom(Math.max(map.getZoom(), 14));
        }else{
          myMarker.setPosition(p);
        }
        const cur = myPath.getPath();
        cur.push(p);
        if(cur.getLength()>500) cur.removeAt(0);

        // C) Persist track point ~1/sec
        if(!startTracking._last || ts - startTracking._last >= 950){
          startTracking._last = ts;
          const point = { lat, lng, ts };
          try{
            await trackColl.doc().set(point);
          }catch(e){
            try{
              const raw = localStorage.getItem(qKey);
              const arr = raw ? JSON.parse(raw) : [];
              arr.push(point);
              localStorage.setItem(qKey, JSON.stringify(arr));
            }catch(_){}
          }
        }

        renderList(); // recompute distances with new self position
      }, err=>{
        console.error(err);
        setMsg("GPS error: " + (err && err.message || err));
      }, { enableHighAccuracy:true, maximumAge:0, timeout:20000 });

      // cleanup hook
      startTracking._stop = ()=>{
        if(myWatch!=null) navigator.geolocation.clearWatch(myWatch);
        myWatch = null;
        clearInterval(flushTimer);
      };
    }

    function stopTracking(){
      if(startTracking._stop) startTracking._stop();
      startTracking._stop = null;
    }

    // ===== Render member list (name, distance, call, focus) =====
    function renderList(){
      membersList.innerHTML = "";
      const meInfo = infos.get(me.uid);
      // sort by name
      const arr = Array.from(infos.entries()).sort((a,b)=> (a[1].name||"").localeCompare(b[1].name||""));
      arr.forEach(([uid,inf])=>{
        const row = document.createElement("div");
        row.className = "member";
        const pos = (inf.lat!=null && inf.lng!=null) ? new google.maps.LatLng(inf.lat, inf.lng) : null;
        let distTxt = "—";
        if(meInfo && meInfo.lat!=null && pos){
          const mePos = new google.maps.LatLng(meInfo.lat, meInfo.lng);
          const meters = google.maps.geometry.spherical.computeDistanceBetween(mePos, pos);
          distTxt = fmtDist(meters);
        }
        row.innerHTML = `
          <div>
            <div class="name" style="color:${inf.color}">${inf.name||"Member"} ${uid===me.uid?'<span class="sub">(you)</span>':''}</div>
            <div class="sub">${pos?('Last '+ago(inf.ts)):'No signal'} • ${distTxt}</div>
          </div>
          <div class="act">
            ${inf.phone?`<a class="badge" href="tel:${encodeURIComponent(inf.phone)}">Call</a>`:''}
            <button class="badge" data-focus="${uid}">Focus</button>
          </div>
        `;
        row.querySelector(`[data-focus="${uid}"]`).onclick = ()=>{
          if(inf.lat!=null && inf.lng!=null){
            const p = new google.maps.LatLng(inf.lat, inf.lng);
            map.panTo(p); map.setZoom(Math.max(map.getZoom(), 15));
            // pulse marker if exists
            const mk = markers.get(uid);
            if(mk){
              const icon = mk.getIcon();
              mk.setIcon({...icon, scale: 11});
              setTimeout(()=> mk.setIcon(icon), 350);
            }
          }
        };
        membersList.appendChild(row);
      });
    }

    // ===== End Trip (admin) =====
    async function endTrip(){
      if(!confirm("End this trip for everyone?")) return;
      try{
        await db.collection("trips").doc(tripId).update({
          isActive: false, endedAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        alert("Trip ended.");
        endTripBtn.disabled = true;
        tripMetaEl.textContent = "Ended";
      }catch(e){
        alert("End trip failed: " + (e && e.message || e));
      }
    }

    // ===== Wire UI =====
    backBtn.onclick = ()=> history.length>1 ? history.back() : location.replace("trips.html");
    endTripBtn.onclick = endTrip;

    // ===== Boot =====
    (async ()=>{
      if(!tripId){ alert("Missing tripId"); location.replace("trips.html"); return; }
      await requireLogin();
      initMap();
      await loadTrip();
      const unsubLive = attachLiveListener();
      await loadTodayTracks();
      await startTracking();   // mandatory GPS on load

      // Also keep my info in infos map for distance calc
      infos.set(me.uid, { name: profile?.name || "Me", phone: profile?.phone || "", lat:null, lng:null, ts:null, color: "#00e676" });

      // Keep my live doc mirrored to infos for distance UI
      db.collection("trips").doc(tripId).collection("live").doc(me.uid)
        .onSnapshot(s=>{
          const d=s.data(); if(!d) return;
          const inf = infos.get(me.uid) || {};
          inf.lat=d.lat; inf.lng=d.lng; inf.ts=d.ts || Date.now();
          infos.set(me.uid, inf);
          renderList();
        });

      // Clean up
      window.addEventListener("beforeunload", ()=>{ stopTracking(); if(unsubLive) unsubLive(); });
    })();
  </script>
</body>
</html>
